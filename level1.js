// Function to start Level 1 of the maze game, it's connected to main.js
export function startLevel1(ctx, player, updateGameTitle, moveToNextLevel) {
    // ensuring features that align with the canvas (17x17 = 510)
    // each cell is 30px
    const gridSize = 17;
    const cellSize = ctx.canvas.width / gridSize;
    const mazeImage = new Image();
    // background image (generated by AI)
    mazeImage.src = "images/Maze1-background.png";

    // The maze structure (2D array)
    let grid = [];
    // other tiles that are needed in this level (collectible, start, and finish goal)
    const dogTile = { row: Math.floor(gridSize / 2), col: Math.floor(gridSize / 2) };
    const startTile = { row: 0, col: 0 };
    const endTile = { row: gridSize - 1, col: gridSize - 1 };
    let hasCollectedDog = false;

    // responsible for creating empty grid for maze/walls
    function createGrid() {
        for (let row = 0; row < gridSize; row++) {
            grid[row] = [];
            for (let col = 0; col < gridSize; col++) {
                grid[row][col] = {
                    visited: false, //track of which walls have been visited
                    walls: [true, true, true, true],
                };
            }
        }
    }
    // generates the maze layout by carving paths in the grid (based on randomized Prim's algorithm) for random generation
    function generateMaze() {
        createGrid();
        // setting player's starting position
        player.row = startTile.row;
        player.col = startTile.col;
        // marking cells as visited
        grid[player.row][player.col].visited = true;

        const walls = [];
        // starting to add walles around the starting point
        addWalls(player.row, player.col, walls);
    // picking random walls and removing them from the list  of walls
        while (walls.length > 0) {
            const randomIndex = Math.floor(Math.random() * walls.length);
            const [row, col, direction] = walls.splice(randomIndex, 1)[0];
            const [dRow, dCol] = directions[direction];
            const newRow = row + dRow;
            const newCol = col + dCol;
            // Checking if the neighboring cell can be visited
            if (isInBounds(newRow, newCol) && !grid[newRow][newCol].visited) {
                grid[row][col].walls[direction] = false;
                grid[newRow][newCol].walls[(direction + 2) % 4] = false;
                grid[newRow][newCol].visited = true;
                addWalls(newRow, newCol, walls);
            }
        }
        // used to update/depict the maze!
        redrawMazeElements();
    }
     // adds the walls of a cell to the list of walls to be processed
    function addWalls(row, col, walls) {
        directions.forEach(([dRow, dCol, dir]) => {
            const newRow = row + dRow;
            const newCol = col + dCol;
            if (isInBounds(newRow, newCol) && !grid[newRow][newCol].visited) {
                walls.push([row, col, dir]);
            }
        });
    }
    // ensuring that the walls are in bounds to avoid generation/moevement errors
    function isInBounds(row, col) {
        return row >= 0 && row < gridSize && col >= 0 && col < gridSize;
    }

    const directions = [
        [-1, 0, 0],
        [0, 1, 1],
        [1, 0, 2],
        [0, -1, 3],
    ];
// function to draw the elements (player/goal/start/collectible ) on the maze canvas
    function redrawMazeElements() {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        if (mazeImage.complete) {
            ctx.drawImage(mazeImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
        } else {
            mazeImage.onload = () => {
                ctx.drawImage(mazeImage, 0, 0, ctx.canvas.width, ctx.canvas.height);
                redrawMazeElements();
            };
            return;
        }
// function to draw walls on each cell
        grid.forEach((row, r) => {
            row.forEach((cell, c) => {
                const x = c * cellSize;
                const y = r * cellSize;

                if (cell.walls[0]) drawWall(x, y, x + cellSize, y);
                if (cell.walls[1]) drawWall(x + cellSize, y, x + cellSize, y + cellSize);
                if (cell.walls[2]) drawWall(x, y + cellSize, x + cellSize, y + cellSize);
                if (cell.walls[3]) drawWall(x, y, x, y + cellSize);
            });
        });
// adding blurs and other visualization to the emojis just for easier visibility for the user
        ctx.save();
        ctx.shadowColor = "blue";
        ctx.shadowBlur = 15;
        ctx.font = `${cellSize * 0.8}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
// condition to pass the level
        if (!hasCollectedDog) {
            ctx.fillText("üê∫", dogTile.col * cellSize + cellSize / 2, dogTile.row * cellSize + cellSize / 2);
        }
// other emojis and their assigned role
        ctx.fillText("üö©", startTile.col * cellSize + cellSize / 2, startTile.row * cellSize + cellSize / 2);
        ctx.fillText("üéØ", endTile.col * cellSize + cellSize / 2, endTile.row * cellSize + cellSize / 2);
        ctx.fillText("üßîüèΩ‚Äç‚ôÄÔ∏è", player.col * cellSize + cellSize / 2, player.row * cellSize + cellSize / 2);

        ctx.restore();
    }

    function drawWall(x1, y1, x2, y2) {
        ctx.beginPath();
        ctx.lineWidth = 3.5;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
// have met what was needed!
    function checkPlayerState() {
        if (player.row === dogTile.row && player.col === dogTile.col) {
            if (!hasCollectedDog) {
                hasCollectedDog = true;
                alert("You found the dog! üê∫ He will guide you to the next level!");
            }
        }
// attempting to cross without the dog
        if (player.row === endTile.row && player.col === endTile.col) {
            if (!hasCollectedDog) {
                alert("You need your dog guide to cross to the next level!");
            } else {
                cleanup();
                moveToNextLevel(true);
            }
        }
    }
// avoiding possible mistakes with the generation of levels (since they share certain functions)
    function cleanup() {
        document.removeEventListener("keydown", handleKeydown);
    }

    function handleKeydown() {
        checkPlayerState();
    }

    document.addEventListener("keydown", handleKeydown);
    mazeImage.onload = generateMaze;

    return { grid, redrawMazeElements, cleanup };
}
